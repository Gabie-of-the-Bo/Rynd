import * from /slice;
import * from /scalar;

// Native library
let RYND_LIB = load_library($MODULE_PATH + "/native/target/release/rynd_native");

// Functions
let MALLOC = RYND_LIB.demut().get_function("malloc");
let FREE = RYND_LIB.demut().get_function("free");

let RYND_CREATE = RYND_LIB.demut().get_function("create_array");
let RYND_FROM_PTR = RYND_LIB.demut().get_function("array_from_ptr");
let RYND_COPY = RYND_LIB.demut().get_function("copy_array");
let RYND_FREE = RYND_LIB.demut().get_function("free_array");

let RYND_CAST = RYND_LIB.demut().get_function("cast_array");

let RYND_SUM = RYND_LIB.demut().get_function("sum_arrays");
let RYND_SUB = RYND_LIB.demut().get_function("sub_arrays");
let RYND_MUL = RYND_LIB.demut().get_function("mul_arrays");
let RYND_DIV = RYND_LIB.demut().get_function("div_arrays");
let RYND_MOD = RYND_LIB.demut().get_function("mod_arrays");
let RYND_POW = RYND_LIB.demut().get_function("pow_arrays");
let RYND_EQ  = RYND_LIB.demut().get_function("eq_arrays");
let RYND_NEQ = RYND_LIB.demut().get_function("neq_arrays");
let RYND_LT = RYND_LIB.demut().get_function("lt_arrays");
let RYND_GT = RYND_LIB.demut().get_function("gt_arrays");
let RYND_LEQ = RYND_LIB.demut().get_function("leq_arrays");
let RYND_GEQ = RYND_LIB.demut().get_function("geq_arrays");
let RYND_IDX = RYND_LIB.demut().get_function("index_arrays");

let RYND_SUM_SCALAR = RYND_LIB.demut().get_function("sum_array_scalar");
let RYND_SUB_SCALAR = RYND_LIB.demut().get_function("sub_array_scalar");
let RYND_MUL_SCALAR = RYND_LIB.demut().get_function("mul_array_scalar");
let RYND_DIV_SCALAR = RYND_LIB.demut().get_function("div_array_scalar");
let RYND_MOD_SCALAR = RYND_LIB.demut().get_function("mod_array_scalar");
let RYND_POW_SCALAR = RYND_LIB.demut().get_function("pow_array_scalar");
let RYND_EQ_SCALAR = RYND_LIB.demut().get_function("eq_array_scalar");
let RYND_NEQ_SCALAR = RYND_LIB.demut().get_function("neq_array_scalar");
let RYND_LT_SCALAR = RYND_LIB.demut().get_function("lt_array_scalar");
let RYND_GT_SCALAR = RYND_LIB.demut().get_function("gt_array_scalar");
let RYND_LEQ_SCALAR = RYND_LIB.demut().get_function("leq_array_scalar");
let RYND_GEQ_SCALAR = RYND_LIB.demut().get_function("geq_array_scalar");

let RYND_IOTA = RYND_LIB.demut().get_function("iota");
let RYND_LINSPACE = RYND_LIB.demut().get_function("linspace");
let RYND_RESHAPE = RYND_LIB.demut().get_function("reshape_array");
let RYND_SLICE = RYND_LIB.demut().get_function("slice_array");

let RYND_PRINT = RYND_LIB.demut().get_function("print_array");

// Array class
class NDArray {
    inner: Pointer;
}

fn destroy(arr: &NDArray) {
    RYND_FREE.demut().call(*arr.inner);
}

implement Destroyable for NDArray;

// Array base interface
interface NDArrayBase {
    fn ptr(obj: Self) -> Pointer;
}

fn ptr(arr: NDArray) -> Pointer {
    return *arr.inner;
}

fn ptr(arr: &NDArray) -> Pointer {
    return *arr.inner;
}

fn ptr(arr: @NDArray) -> Pointer {
    return *arr.inner;
}

implement NDArrayBase for NDArray;
implement NDArrayBase for &NDArray;
implement NDArrayBase for @NDArray;

// Array creation
fn write_to_ptr(ptr: Pointer, offset: Int, value: Int) {
    write_ptr_int(*ptr, *offset, *value);
}

fn write_to_ptr(ptr: Pointer, offset: Int, value: Float) {
    write_ptr_float(*ptr, *offset, *value);
}

fn<S, SI> ndarray(arr: Array<'S [Scalar<'SI>]>) -> NDArray {
    let ptr = MALLOC.demut().call(arr.len()).as<Pointer>();
    let offset = 0;

    for i in arr {
        write_to_ptr(*ptr, *offset, i.cfwd<'S>().scalar());
        offset.inc();
    }

    let res = RYND_FROM_PTR.demut().call(*ptr, type(arr[0].cfwd<'S>()), 1, arr.len()).as<Pointer>();

    FREE.demut().call(*ptr, arr.len());

    return NDArray(*res);
}

fn<S, SI> ndarray(arr: Array<Array<'S [Scalar<'SI>]>>) -> NDArray {
    let height = arr.len();
    let width = arr[0].len();
    let size = height * width; 

    for v in arr {
        if v.len() != width {
            panic("Unable to convert ragged array to NDArray");
        }
    }

    let ptr = MALLOC.demut().call(*size).as<Pointer>();
    let offset = 0;

    for v in arr {
        for i in v {
            write_to_ptr(*ptr, *offset, i.cfwd<'S>().scalar());
            offset.inc();
        }
    }

    let res = RYND_FROM_PTR.demut().call(*ptr, type((arr[0])[0].cfwd<'S>()), 2, *height, *width).as<Pointer>();

    FREE.demut().call(*ptr, *size);

    return NDArray(*res);
}

fn zeros(t: Int, l: Int) -> NDArray {
    return NDArray(RYND_CREATE.demut().call(*t, 1, *l).as<Pointer>());
}

fn iota(l: Int) -> NDArray {
    return NDArray(RYND_IOTA.demut().call(*l).as<Pointer>());
}

fn linspace(f: Int, t: Int) -> NDArray {
    return NDArray(RYND_LINSPACE.demut().call(*f, *t, 1).as<Pointer>());
}

fn linspace(f: Int, t: Int, s: Int) -> NDArray {
    return NDArray(RYND_LINSPACE.demut().call(*f, *t, *s).as<Pointer>());
}

fn<T> reshape(arr: 'T [NDArrayBase], d0: Int) -> NDArray {
    return NDArray(RYND_RESHAPE.demut().call(arr.ptr(), 1, *d0).as<Pointer>());
}

fn<T> reshape(arr: 'T [NDArrayBase], d0: Int, d1: Int) -> NDArray {
    return NDArray(RYND_RESHAPE.demut().call(arr.ptr(), 2, *d0, *d1).as<Pointer>());
}

fn<T> reshape(arr: 'T [NDArrayBase], d0: Int, d1: Int, d2: Int) -> NDArray {
    return NDArray(RYND_RESHAPE.demut().call(arr.ptr(), 3, *d0, *d1, *d2).as<Pointer>());
}

fn<T> reshape(arr: 'T [NDArrayBase], d0: Int, d1: Int, d2: Int, d3: Int) -> NDArray {
    return NDArray(RYND_RESHAPE.demut().call(arr.ptr(), 4, *d0, *d1, *d2, *d3).as<Pointer>());
}

fn<T> reshape(arr: 'T [NDArrayBase], d0: Int, d1: Int, d2: Int, d3: Int, d4: Int) -> NDArray {
    return NDArray(RYND_RESHAPE.demut().call(arr.ptr(), 5, *d0, *d1, *d2, *d3, *d4).as<Pointer>());
}

fn<L, R> pow(a: 'L [NDArrayBase], b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_POW.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

fn<A, S, SI> pow(a: 'A [NDArrayBase], b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_POW_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

fn<A, S, SI> pow(b: 'S [Scalar<'SI>], a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_POW_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

fn<T> copy(arr: 'T [NDArrayBase]) -> NDArray {
    return NDArray(RYND_COPY.demut().call(arr.ptr()).as<Pointer>());
}

// Casts
fn<T> int(arr: 'T [NDArrayBase]) -> NDArray {
    return NDArray(RYND_CAST.demut().call(arr.ptr(), 1).as<Pointer>());
}

fn<T> float(arr: 'T [NDArrayBase]) -> NDArray {
    return NDArray(RYND_CAST.demut().call(arr.ptr(), 2).as<Pointer>());
}

fn<T> bool(arr: 'T [NDArrayBase]) -> NDArray {
    return NDArray(RYND_CAST.demut().call(arr.ptr(), 3).as<Pointer>());
}

// Operators
op<L, R> (a: 'L [NDArrayBase]) + (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_SUM.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) + (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_SUM_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) + (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_SUM_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) - (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_SUB_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) - (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_SUB_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) * (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_MUL_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) * (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_MUL_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) / (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_DIV_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) / (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_DIV_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) % (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_MOD_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) % (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_MOD_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) == (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_EQ_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) == (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_EQ_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) != (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_NEQ_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) != (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_NEQ_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) < (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_LT_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) < (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_LT_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) > (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_GT_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) > (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_GT_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) <= (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_LEQ_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) <= (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_LEQ_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<A, S, SI> (a: 'A [NDArrayBase]) >= (b: 'S [Scalar<'SI>]) -> NDArray {
    return NDArray(RYND_GEQ_SCALAR.demut().call(a.ptr(), b.scalar(), 0).as<Pointer>());
}

op<A, S, SI> (b: 'S [Scalar<'SI>]) >= (a: 'A [NDArrayBase]) -> NDArray {
    return NDArray(RYND_GEQ_SCALAR.demut().call(a.ptr(), b.scalar(), 1).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) - (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_SUB.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) * (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_MUL.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) / (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_DIV.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) % (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_MOD.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) == (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_EQ.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) != (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_NEQ.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) < (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_LT.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) > (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_GT.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) <= (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_LEQ.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase]) >= (b: 'R [NDArrayBase]) -> NDArray {
    return NDArray(RYND_GEQ.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L, R> (a: 'L [NDArrayBase])[b: 'R [NDArrayBase]] -> NDArray {
    return NDArray(RYND_IDX.demut().call(a.ptr(), b.ptr()).as<Pointer>());
}

op<L> (a: 'L [NDArrayBase])[s0: Slice] -> NDArray {
    return NDArray(RYND_SLICE.demut().call(a.ptr(), 1, *s0.from_idx, *s0.to_idx, *s0.step).as<Pointer>());
}

op<L> (a: 'L [NDArrayBase])[s0: Slice, s1: Slice] -> NDArray {
    return NDArray(
        RYND_SLICE.demut().call(a.ptr(), 2, 
        *s0.from_idx, *s0.to_idx, *s0.step, 
        *s1.from_idx, *s1.to_idx, *s1.step
    ).as<Pointer>());
}

op<L> (a: 'L [NDArrayBase])[s0: Slice, s1: Slice, s2: Slice] -> NDArray {
    return NDArray(
        RYND_SLICE.demut().call(a.ptr(), 3, 
        *s0.from_idx, *s0.to_idx, *s0.step, 
        *s1.from_idx, *s1.to_idx, *s1.step, 
        *s2.from_idx, *s2.to_idx, *s2.step
    ).as<Pointer>());
}

op<L> (a: 'L [NDArrayBase])[s0: Slice, s1: Slice, s2: Slice, s3: Slice] -> NDArray {
    return NDArray(
        RYND_SLICE.demut().call(a.ptr(), 4, 
        *s0.from_idx, *s0.to_idx, *s0.step, 
        *s1.from_idx, *s1.to_idx, *s1.step, 
        *s2.from_idx, *s2.to_idx, *s2.step, 
        *s3.from_idx, *s3.to_idx, *s3.step
    ).as<Pointer>());
}

op<L> (a: 'L [NDArrayBase])[s0: Slice, s1: Slice, s2: Slice, s3: Slice, s4: Slice] -> NDArray {
    return NDArray(
        RYND_SLICE.demut().call(a.ptr(), 5, 
        *s0.from_idx, *s0.to_idx, *s0.step, 
        *s1.from_idx, *s1.to_idx, *s1.step, 
        *s2.from_idx, *s2.to_idx, *s2.step, 
        *s3.from_idx, *s3.to_idx, *s3.step, 
        *s4.from_idx, *s4.to_idx, *s4.step
    ).as<Pointer>());
}

// Formatting
fn<T> print(arr: 'T [NDArrayBase]) {
    RYND_PRINT.demut().call(arr.ptr());
}